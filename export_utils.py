import os
import tempfile
import base64
import html
import json
import pandas as pd
from fpdf import FPDF
import matplotlib.pyplot as plt
import seaborn as sns
from io import BytesIO

def export_to_pdf(question, answer, context, include_visualization=False, chart_data=None):
    """
    Export the conversation and optional visualization to a PDF file.
    
    Args:
        question: The user's question
        answer: The AI's answer
        context: The context used to generate the answer
        include_visualization: Whether to include a visualization
        chart_data: Data for the visualization (if applicable)
        
    Returns:
        Path to the generated PDF file
    """
    pdf = FPDF()
    pdf.add_page()
    
    # Add header with telecom styling
    pdf.set_fill_color(0, 83, 156)  # Telecom blue
    pdf.rect(0, 0, 210, 20, 'F')
    pdf.set_font("Arial", 'B', 16)
    pdf.set_text_color(255, 255, 255)
    pdf.cell(0, 20, "Telecom AI Report", 0, 1, 'C')
    
    # Reset text color
    pdf.set_text_color(0, 0, 0)
    
    # Add content
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, "Question:", 0, 1)
    pdf.set_font("Arial", size=11)
    safe_question = html.unescape(question).encode("latin-1", "replace").decode("latin-1")
    pdf.multi_cell(0, 10, safe_question)
    
    pdf.ln(5)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, "Answer:", 0, 1)
    pdf.set_font("Arial", size=11)
    safe_answer = html.unescape(answer).encode("latin-1", "replace").decode("latin-1")
    pdf.multi_cell(0, 10, safe_answer)
    
    # Add visualization if requested
    if include_visualization and chart_data is not None:
        pdf.ln(5)
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(0, 10, "Visualization:", 0, 1)
        
        # Create visualization
        plt.figure(figsize=(8, 4))
        
        # Example visualization - adapt based on your data
        if isinstance(chart_data, pd.DataFrame):
            sns.barplot(data=chart_data)
        elif isinstance(chart_data, dict):
            plt.bar(chart_data.keys(), chart_data.values())
        
        # Save plot to temporary file
        img_path = os.path.join(tempfile.gettempdir(), "chart.png")
        plt.savefig(img_path)
        plt.close()
        
        # Add image to PDF
        pdf.image(img_path, x=10, y=None, w=180)
    
    # Add context at the end
    pdf.ln(10)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, "Context Used:", 0, 1)
    pdf.set_font("Arial", size=10)
    safe_context = html.unescape(context).encode("latin-1", "replace").decode("latin-1")
    pdf.multi_cell(0, 8, safe_context)
    
    # Add footer
    pdf.set_y(-15)
    pdf.set_font("Arial", 'I', 8)
    pdf.cell(0, 10, f"Generated by TelcoRAG - Page {pdf.page_no()}", 0, 0, 'C')
    
    pdf_path = os.path.join(tempfile.gettempdir(), "telecom_report.pdf")
    pdf.output(pdf_path)
    return pdf_path

def export_to_excel(question, answer, context, include_data=None):
    """
    Export the conversation and optional data to an Excel file.
    
    Args:
        question: The user's question
        answer: The AI's answer
        context: The context used to generate the answer
        include_data: Optional structured data to include in a separate sheet
        
    Returns:
        Path to the generated Excel file
    """
    # Create a pandas Excel writer
    excel_path = os.path.join(tempfile.gettempdir(), "telecom_report.xlsx")
    writer = pd.ExcelWriter(excel_path, engine='xlsxwriter')
    
    # Create DataFrame for the conversation
    conversation_df = pd.DataFrame({
        "Question": [question],
        "Answer": [answer],
        "Context": [context]
    })
    
    # Write conversation to the Excel file
    conversation_df.to_excel(writer, sheet_name='Report', index=False)
    
    # Format the worksheet
    workbook = writer.book
    worksheet = writer.sheets['Report']
    
    # Add formatting
    header_format = workbook.add_format({
        'bold': True,
        'text_wrap': True,
        'valign': 'top',
        'fg_color': '#0053A0',  # Telecom blue
        'font_color': 'white',
        'border': 1
    })
    
    # Write the column headers with the defined format
    for col_num, value in enumerate(conversation_df.columns.values):
        worksheet.write(0, col_num, value, header_format)
        
    # Set column widths
    worksheet.set_column('A:A', 30)
    worksheet.set_column('B:B', 50)
    worksheet.set_column('C:C', 50)
    
    # Add a data sheet if data is provided
    if include_data is not None and isinstance(include_data, pd.DataFrame):
        include_data.to_excel(writer, sheet_name='Data', index=False)
        
        # Format the data sheet
        data_worksheet = writer.sheets['Data']
        for col_num, value in enumerate(include_data.columns.values):
            data_worksheet.write(0, col_num, value, header_format)
    
    # Close the writer and save the Excel file
    writer.close()
    
    return excel_path

def export_to_json(question, answer, context, include_data=None):
    """
    Export the conversation and optional data to a JSON file.
    
    Args:
        question: The user's question
        answer: The AI's answer
        context: The context used to generate the answer
        include_data: Optional structured data to include
        
    Returns:
        Path to the generated JSON file
    """
    # Create the JSON structure
    report_data = {
        "report_type": "Telecom AI Analysis",
        "timestamp": pd.Timestamp.now().isoformat(),
        "conversation": {
            "question": question,
            "answer": answer
        },
        "context": context
    }
    
    # Add additional data if provided
    if include_data is not None:
        if isinstance(include_data, pd.DataFrame):
            report_data["data"] = include_data.to_dict(orient='records')
        elif isinstance(include_data, dict):
            report_data["data"] = include_data
    
    # Write to JSON file
    json_path = os.path.join(tempfile.gettempdir(), "telecom_report.json")
    with open(json_path, 'w') as f:
        json.dump(report_data, f, indent=4)
    
    return json_path

def get_download_link(file_path, label):
    """
    Create a download link for a file.
    
    Args:
        file_path: Path to the file
        label: Label for the download button
        
    Returns:
        HTML string with the download link
    """
    with open(file_path, "rb") as f:
        data = f.read()
    b64 = base64.b64encode(data).decode()
    file_name = os.path.basename(file_path)
    mime_types = {
        '.pdf': 'application/pdf',
        '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        '.json': 'application/json'
    }
    file_ext = os.path.splitext(file_path)[1]
    mime_type = mime_types.get(file_ext, 'application/octet-stream')
    
    href = f'<a href="data:{mime_type};base64,{b64}" download="{file_name}" class="download-button">{label}</a>'
    return href

def create_sample_visualization(data_type="network_performance"):
    """
    Create a sample visualization for demo purposes.
    
    Args:
        data_type: Type of telecom data to visualize
        
    Returns:
        BytesIO object containing the visualization
    """
    plt.figure(figsize=(10, 6))
    
    if data_type == "network_performance":
        # Sample network performance data
        sites = ['Site A', 'Site B', 'Site C', 'Site D', 'Site E']
        uptime = [99.8, 97.5, 99.9, 98.2, 99.5]
        latency = [15, 22, 12, 18, 14]
        
        # Create a DataFrame
        df = pd.DataFrame({
            'Site': sites,
            'Uptime (%)': uptime,
            'Latency (ms)': latency
        })
        
        # Create the plot
        ax = sns.barplot(x='Site', y='Uptime (%)', data=df, color='blue')
        ax2 = ax.twinx()
        sns.lineplot(x='Site', y='Latency (ms)', data=df, color='red', marker='o', ax=ax2)
        
        # Add labels and title
        ax.set_xlabel('Site Location')
        ax.set_ylabel('Uptime (%)')
        ax2.set_ylabel('Latency (ms)')
        plt.title('Network Performance by Site')
        
        # Add legend
        lines, labels = ax.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax2.legend(lines + lines2, labels + labels2, loc='upper right')
        
    elif data_type == "customer_complaints":
        # Sample customer complaint data
        categories = ['Network Outage', 'Slow Speed', 'Billing Issues', 
                      'Customer Service', 'Equipment Failure']
        counts = [45, 78, 32, 28, 15]
        
        # Create the plot
        plt.pie(counts, labels=categories, autopct='%1.1f%%', startangle=90, 
                colors=['#ff9999','#66b3ff','#99ff99','#ffcc99','#c2c2f0'])
        plt.axis('equal')
        plt.title('Customer Complaint Distribution')
        
    elif data_type == "site_traffic":
        # Sample site traffic data
        hours = list(range(24))
        traffic = [20, 15, 10, 8, 5, 10, 25, 45, 60, 70, 75, 80, 
                  85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 30, 25]
        
        # Create the plot
        plt.plot(hours, traffic, marker='o', linestyle='-', color='green')
        plt.fill_between(hours, traffic, alpha=0.2, color='green')
        plt.xlabel('Hour of Day')
        plt.ylabel('Traffic Volume (Gbps)')
        plt.title('24-Hour Traffic Pattern')
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.xticks(range(0, 24, 2))
    
    # Save the plot to a BytesIO object
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    plt.close()
    
    return buf